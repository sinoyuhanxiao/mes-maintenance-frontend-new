/**
 * Task Step Change Tracking Utility
 *
 * This module provides functions for tracking changes to task steps during work order editing.
 * It follows the same pattern used for template editing in templateTransforms.js.
 *
 * Purpose: When editing a work order, we need to track which steps were:
 * - Added (new steps with temporary IDs)
 * - Updated (existing steps that were modified)
 * - Deleted (steps that were removed)
 *
 * This allows the backend to perform targeted database operations instead of
 * replacing all steps, which can cause data loss or duplication.
 */

/**
 * Calculate step changes for a single task by comparing current and original steps
 * @param {Object} currentTask - The task with current steps (after user edits)
 * @param {Object} originalTask - The task with original steps (before edits)
 * @returns {Object} Object with step_add_list, step_update_list, step_delete_list
 */
export function calculateStepChangesForTask( currentTask, originalTask ) {
  // 1. Extract step arrays from different possible locations
  const currentSteps = Array.isArray( currentTask.steps )
    ? currentTask.steps
    : Array.isArray( currentTask.payload?.steps )
      ? currentTask.payload.steps
      : []

  const originalSteps = Array.isArray( originalTask.steps )
    ? originalTask.steps
    : Array.isArray( originalTask.payload?.steps )
      ? originalTask.payload.steps
      : []

  // 2. Create comparison maps for efficient lookup
  // Map: stepId -> step object
  const originalStepsMap = new Map()
  originalSteps.forEach( step => {
    const stepId = step.id || step._id || step.step_id
    if ( stepId ) {
      // Normalize ID to string for consistent comparison
      originalStepsMap.set( String( stepId ), step )
    }
  } )

  const currentStepsMap = new Map()
  currentSteps.forEach( step => {
    const stepId = step.id || step._id || step.step_id
    // Only map steps with real backend IDs (not temporary frontend IDs)
    if ( stepId && !isTemporaryId( stepId ) ) {
      // Normalize ID to string for consistent comparison
      currentStepsMap.set( String( stepId ), step )
    }
  } )

  // 3. Initialize result object
  const stepChanges = {
    step_add_list : [],
    step_update_list : [],
    step_delete_list : []
  }

  // 4. Process current steps to find adds and updates
  currentSteps.forEach( step => {
    const stepId = step.id || step._id || step.step_id

    if ( !stepId || isTemporaryId( stepId ) ) {
      // New step - has temporary frontend ID or no ID
      const cleanStep = prepareStepForAdd( step )
      // Only add if not null (filters out auto-generated steps)
      if ( cleanStep ) {
        stepChanges.step_add_list.push( cleanStep )
      }
    } else if ( originalStepsMap.has( String( stepId ) ) ) {
      // Existing step - check if it was actually modified
      if ( isStepModified( step, originalStepsMap.get( String( stepId ) ) ) ) {
        const updateStep = prepareStepForUpdate( step )
        stepChanges.step_update_list.push( updateStep )
      }
    }
  } )

  // 5. Find deleted steps (in original but not in current)
  originalSteps.forEach( originalStep => {
    const stepId = originalStep.id || originalStep._id || originalStep.step_id
    if ( stepId && !currentStepsMap.has( String( stepId ) ) ) {
      // Step was deleted - validate ID before adding to delete list
      if ( isValidStepId( stepId ) ) {
        stepChanges.step_delete_list.push( stepId )
      }
    }
  } )

  return stepChanges
}

/**
 * Check if a step ID is temporary (generated by frontend, not yet saved to backend)
 * @param {string|number} id - The step ID to check
 * @returns {boolean} True if the ID is temporary
 */
function isTemporaryId( id ) {
  if ( !id ) return true

  const idStr = String( id )

  // Frontend-generated IDs typically start with these prefixes
  return (
    idStr.startsWith( 'step-' ) || idStr.startsWith( 'new-' ) || idStr.startsWith( 'temp-' ) || idStr.startsWith( 'local-' )
  )
}

/**
 * Check if a step was modified by comparing current and original versions
 * @param {Object} currentStep - The step after user edits
 * @param {Object} originalStep - The step before edits
 * @returns {boolean} True if the step was modified
 */
function isStepModified( currentStep, originalStep ) {
  // Compare key step properties
  const propsToCompare = ['name', 'description', 'required', 'remarks', 'type']

  for ( const prop of propsToCompare ) {
    if ( currentStep[prop] !== originalStep[prop] ) {
      return true
    }
  }

  // Compare step value (the actual input configuration)
  // This includes the step type (checkbox, number, text, etc.) and its settings
  const currentValue = JSON.stringify( currentStep.value || {} )
  const originalValue = JSON.stringify( originalStep.value || {} )
  if ( currentValue !== originalValue ) {
    return true
  }

  // Compare tools (array of tool IDs or tool objects)
  const currentTools = normalizeToolsForComparison( currentStep.tools )
  const originalTools = normalizeToolsForComparison( originalStep.tools )
  if ( currentTools !== originalTools ) {
    return true
  }

  return false
}

/**
 * Normalize tools array for comparison (handles both ID arrays and object arrays)
 * @param {Array} tools - Array of tool IDs or tool objects
 * @returns {string} Stringified sorted array of tool IDs
 */
function normalizeToolsForComparison( tools ) {
  if ( !Array.isArray( tools ) ) return '[]'

  // Extract IDs from tools (handles both number arrays and object arrays)
  const toolIds = tools
    .map( tool => {
      if ( typeof tool === 'number' ) return tool
      if ( typeof tool === 'object' && tool !== null ) {
        return tool.id || tool.tool_id || tool.toolId
      }
      return tool
    } )
    .filter( id => id != null )

  // Sort for consistent comparison
  return JSON.stringify( toolIds.sort( ( a, b ) => a - b ) )
}

/**
 * Prepare a step for adding to the backend (new step, no ID needed)
 * @param {Object} step - The step to prepare
 * @returns {Object} Clean step object ready for backend
 */
function prepareStepForAdd( step ) {
  // Filter out auto-generated fallback steps - they shouldn't be sent as new steps
  const isAutoGeneratedStep =
    step.name === 'Checklist' && step.description === 'Auto-generated step' && step.type === 'template'

  if ( isAutoGeneratedStep ) {
    return null
  }

  return {
    name : step.name || 'Untitled Step',
    description : step.description || '',
    type : step.type || 'template',
    required : step.required || false,
    remarks : step.remarks || '',
    value : step.value || {},
    tools : extractToolIds( step.tools )
  }
}

/**
 * Prepare a step for updating on the backend (existing step, ID required)
 * @param {Object} step - The step to prepare
 * @returns {Object} Step object with ID ready for backend update
 */
function prepareStepForUpdate( step ) {
  const stepId = step.id || step._id || step.step_id

  return {
    id : stepId, // Include ID for updates
    name : step.name || 'Untitled Step',
    description : step.description || '',
    type : step.type || 'template',
    required : step.required || false,
    remarks : step.remarks || '',
    value : step.value || {},
    tools : extractToolIds( step.tools )
  }
}

/**
 * Extract tool IDs from tools array (handles both ID arrays and object arrays)
 * Backend expects an array of tool IDs (integers)
 * @param {Array} tools - Array of tool IDs or tool objects
 * @returns {Array<number>} Array of tool IDs
 */
function extractToolIds( tools ) {
  if ( !Array.isArray( tools ) ) return []

  return tools
    .map( tool => {
      // If it's already a number, return it
      if ( typeof tool === 'number' ) return tool

      // If it's an object, extract the ID
      if ( typeof tool === 'object' && tool !== null ) {
        return tool.id || tool.tool_id || tool.toolId
      }

      // If it's a string number, parse it
      if ( typeof tool === 'string' && !isNaN( tool ) ) {
        return parseInt( tool, 10 )
      }

      return null
    } )
    .filter( id => id != null && !isNaN( id ) )
}

/**
 * Validate that a step ID is usable for backend operations
 * @param {string|number} id - The step ID to validate
 * @returns {boolean} True if the ID is valid
 */
function isValidStepId( id ) {
  if ( !id ) return false

  const idStr = String( id )

  // Check for invalid placeholder values
  return idStr !== 'null' && idStr !== 'undefined' && idStr.length > 0 && !isTemporaryId( id )
}

/**
 * Check if a step is an auto-generated fallback step
 * @param {Object} step - The step to check
 * @returns {boolean} True if the step is auto-generated
 */
function isAutoGeneratedStep( step ) {
  return step.name === 'Checklist' && step.description === 'Auto-generated step' && step.type === 'template'
}

/**
 * Check if any steps have changed between current and original task
 * Used to optimize - only calculate detailed changes if we know something changed
 * @param {Array} currentSteps - Current step array
 * @param {Array} originalSteps - Original step array
 * @returns {boolean} True if any step changed
 */
export function hasAnyStepChanged( currentSteps, originalSteps ) {
  // Filter out auto-generated steps from both arrays for comparison
  const filteredCurrent = currentSteps.filter( step => !isAutoGeneratedStep( step ) )
  const filteredOriginal = originalSteps.filter( step => !isAutoGeneratedStep( step ) )

  // Quick check: different number of steps (excluding auto-generated)
  if ( filteredCurrent.length !== filteredOriginal.length ) return true

  // If both are empty (only had auto-generated steps), nothing changed
  if ( filteredCurrent.length === 0 && filteredOriginal.length === 0 ) return false

  // Create a map of original steps by ID for quick lookup
  const originalMap = new Map()
  filteredOriginal.forEach( step => {
    const id = step.id || step._id || step.step_id
    // Normalize ID to string for consistent comparison
    if ( id ) originalMap.set( String( id ), step )
  } )

  // Check each current step
  for ( const currentStep of filteredCurrent ) {
    const stepId = currentStep.id || currentStep._id || currentStep.step_id

    // New step (temporary ID or no ID)
    if ( !stepId || isTemporaryId( stepId ) ) {
      return true
    }

    // Check if this specific step was modified
    const originalStep = originalMap.get( String( stepId ) )
    if ( !originalStep ) {
      // Step exists in current but not in original
      return true
    }

    if ( isStepModified( currentStep, originalStep ) ) {
      return true
    }
  }

  // Check for deleted steps
  const currentMap = new Map()
  filteredCurrent.forEach( step => {
    const id = step.id || step._id || step.step_id
    if ( id && !isTemporaryId( id ) ) {
      // Normalize ID to string for consistent comparison
      currentMap.set( String( id ), step )
    }
  } )

  for ( const originalStep of filteredOriginal ) {
    const stepId = originalStep.id || originalStep._id || originalStep.step_id
    if ( stepId && !currentMap.has( String( stepId ) ) ) {
      // Step was deleted
      return true
    }
  }

  return false
}
