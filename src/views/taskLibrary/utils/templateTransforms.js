// Template transformation utilities for converting between frontend and backend formats
import { transformLimitsToBackend } from './stepTransforms'

/**
 * Check if a step ID is temporary (generated by frontend, not yet saved to backend)
 * @param {string|number} id - The step ID to check
 * @returns {boolean} True if the ID is temporary
 */
function isTemporaryId( id ) {
  if ( !id ) return true

  const idStr = String( id )

  // Frontend-generated IDs typically start with these prefixes
  return (
    idStr.startsWith( 'step-' ) ||
    idStr.startsWith( 'new-' ) ||
    idStr.startsWith( 'temp-' ) ||
    idStr.startsWith( 'local-' )
  )
}

// Category name-to-ID mapping for template categorization
export const CATEGORY_MAP = {
  'Preventive Maintenance' : 1,
  'Preventative Maintenance' : 1,
  PM : 1,
  Inspection : 2,
  Repair : 3,
  'Corrective Maintenance' : 3,
  Calibration : 4,
  'Safety Check' : 5,
  Safety : 5,
  Other : 6,
  General : 6
}

// Default category ID for uncategorized templates
export const DEFAULT_CATEGORY_ID = 6

/**
 * Transform frontend template data to backend API format for creation
 * @param {Object} frontendData - Template data from frontend form
 * @returns {Object} Backend API payload for template creation
 */
export const transformTemplateForBackend = frontendData => {
  // Validate input
  if ( !frontendData || typeof frontendData !== 'object' ) {
    throw new Error( 'Invalid template data provided for transformation' )
  }

  // Transform steps from frontend format to backend format
  const transformedSteps = ( frontendData.steps || [] )
    .map( step => {
      if ( !step || typeof step !== 'object' ) {
        return null
      }

      // Create the base step structure
      const backendStep = {
        name : step.label || step.name || 'Untitled Step',
        description : step.description || '',
        type : 'template', // All steps are template type for creation
        required : Boolean( step.required ),
        remarks : step.remarks || ''
      }

      // PRESERVE STEP ID if it exists (critical for editing existing tasks/work orders)
      // When editing a standalone task, step IDs must be preserved so the backend
      // can properly track which steps were added/updated/deleted
      const stepId = step.id || step._id || step.step_id
      if ( stepId && !isTemporaryId( stepId ) ) {
        backendStep.id = stepId
      }

      // Add tools if they exist (send as ID array per new API)
      if ( step.relevant_tools && Array.isArray( step.relevant_tools ) && step.relevant_tools.length > 0 ) {
        backendStep.tools = step.relevant_tools
          .map( tool => {
            if ( typeof tool === 'object' && tool.tool_id ) {
              return parseInt( tool.tool_id ) || 0
            } else if ( typeof tool === 'object' && tool.id ) {
              return parseInt( tool.id ) || 0
            } else {
              return parseInt( tool ) || 0
            }
          } )
          .filter( id => id > 0 ) // Remove invalid tool IDs
      }

      // Transform step value based on frontend step type
      // Backend expects these exact type IDs: [checkbox, file, inspection, numeric, service, text]
      const stepConfig = step.config || {}
      switch ( step.type ) {
        case 'number':
          backendStep.value = {
            type : 'numeric',
            value : parseFloat( stepConfig.default_value ) || 0,
            numeric_limit_bounds : transformLimitsToBackend( stepConfig.limits ),
            require_image : Boolean( step.required_image ),
            image : []
          }
          break

        case 'checkbox':
          backendStep.value = {
            type : 'checkbox', // Backend expects 'checkbox' for checkbox steps
            value : Boolean( stepConfig.default ),
            require_image : Boolean( step.required_image ),
            image : []
          }
          break

        case 'text':
          backendStep.value = {
            type : 'text',
            value : String( stepConfig.default_value || '' ),
            require_image : Boolean( step.required_image ),
            image : []
          }
          break

        case 'inspection':
          backendStep.value = {
            type : 'inspection',
            value : stepConfig.default === 'pass',
            remarks : '',
            require_image : Boolean( step.required_image ),
            image : []
          }
          break

        case 'attachments':
          backendStep.value = {
            type : 'file',
            file : []
          }
          break

        default:
          backendStep.value = {
            type : 'checkbox', // Default to checkbox type instead of boolean
            value : false,
            require_image : Boolean( step.required_image ),
            image : []
          }
      }

      return backendStep
    } )
    .filter( Boolean ) // Remove any null steps

  // Build the backend payload
  const backendPayload = {
    name : frontendData.name,
    description : frontendData.description || '',
    time_estimate_sec : frontendData.estimated_minutes ? frontendData.estimated_minutes * 60 : 1800,
    steps : transformedSteps
  }

  // Add equipment_node_id if applicable_assets contains a numeric ID
  if ( frontendData.applicable_assets ) {
    if ( typeof frontendData.applicable_assets === 'number' ) {
      backendPayload.equipment_node_id = frontendData.applicable_assets
    } else if ( typeof frontendData.applicable_assets === 'string' && !isNaN( frontendData.applicable_assets ) ) {
      backendPayload.equipment_node_id = parseInt( frontendData.applicable_assets )
    } else if ( Array.isArray( frontendData.applicable_assets ) && frontendData.applicable_assets.length > 0 ) {
      // Fallback for legacy array format - take the first asset
      const firstAsset = frontendData.applicable_assets[0]
      if ( typeof firstAsset === 'number' ) {
        backendPayload.equipment_node_id = firstAsset
      } else if ( typeof firstAsset === 'string' && !isNaN( firstAsset ) ) {
        backendPayload.equipment_node_id = parseInt( firstAsset )
      }
    }
  }

  // Add category_id - handle both string names and numeric IDs
  if ( frontendData.category ) {
    // If it's already a number, use it directly
    const categoryId = parseInt( frontendData.category )
    if ( !isNaN( categoryId ) && categoryId > 0 ) {
      backendPayload.category_id = categoryId
    } else {
      backendPayload.category_id = CATEGORY_MAP[frontendData.category] || DEFAULT_CATEGORY_ID
    }
  } else {
    backendPayload.category_id = DEFAULT_CATEGORY_ID // Default to 'Other' if no category
  }

  return backendPayload
}

/**
 * Transform frontend template data for PATCH update operations
 * @param {Object} frontendData - Updated template data from frontend
 * @param {Object} originalTemplate - Original template for comparison
 * @returns {Object} Backend API payload for template update
 */
export const transformTemplateForUpdate = ( frontendData, originalTemplate ) => {
  // Validate input
  if ( !frontendData || typeof frontendData !== 'object' ) {
    throw new Error( 'Invalid template data provided for update transformation' )
  }

  const updatePayload = {}

  // Update basic metadata fields
  if ( frontendData.name !== undefined ) {
    updatePayload.name = frontendData.name
  }

  if ( frontendData.description !== undefined ) {
    updatePayload.description = frontendData.description
  }

  if ( frontendData.estimated_minutes !== undefined ) {
    updatePayload.time_estimate_sec = frontendData.estimated_minutes * 60
  }

  // Handle equipment_node_id
  if ( frontendData.applicable_assets !== undefined ) {
    if ( frontendData.applicable_assets === null || frontendData.applicable_assets === '' ) {
      updatePayload.equipment_node_id = null
    } else if ( typeof frontendData.applicable_assets === 'number' ) {
      updatePayload.equipment_node_id = frontendData.applicable_assets
    } else if ( typeof frontendData.applicable_assets === 'string' && !isNaN( frontendData.applicable_assets ) ) {
      updatePayload.equipment_node_id = parseInt( frontendData.applicable_assets )
    } else if ( Array.isArray( frontendData.applicable_assets ) && frontendData.applicable_assets.length > 0 ) {
      // Fallback for legacy array format - take the first asset
      const firstAsset = frontendData.applicable_assets[0]
      if ( typeof firstAsset === 'number' ) {
        updatePayload.equipment_node_id = firstAsset
      } else if ( typeof firstAsset === 'string' && !isNaN( firstAsset ) ) {
        updatePayload.equipment_node_id = parseInt( firstAsset )
      }
    } else if ( Array.isArray( frontendData.applicable_assets ) && frontendData.applicable_assets.length === 0 ) {
      updatePayload.equipment_node_id = null
    }
  }

  // Handle category_id
  if ( frontendData.category ) {
    const categoryId = parseInt( frontendData.category )
    if ( !isNaN( categoryId ) && categoryId > 0 ) {
      updatePayload.category_id = categoryId
    } else {
      updatePayload.category_id = CATEGORY_MAP[frontendData.category] || DEFAULT_CATEGORY_ID
    }
  }

  // Handle steps - determine what steps are added, updated, or deleted
  const currentSteps = frontendData.steps || []
  const originalSteps = ( originalTemplate && originalTemplate.steps ) || []

  // Create maps for easier comparison
  const originalStepsMap = new Map()
  originalSteps.forEach( step => {
    // Handle different ID field names from API
    const stepId = step.id || step._id || step.step_id
    if ( stepId ) {
      originalStepsMap.set( stepId, step )
    }
  } )

  const currentStepsMap = new Map()
  currentSteps.forEach( step => {
    const stepId = step.step_id
    if ( stepId && !stepId.startsWith( 'step-' ) ) {
      // Only map steps with real backend IDs
      currentStepsMap.set( stepId, step )
    }
  } )

  // Initialize step operation lists
  updatePayload.step_add_list = []
  updatePayload.step_update_list = []
  updatePayload.step_delete_list = []

  // Process current steps to identify adds and updates
  currentSteps.forEach( step => {
    const stepId = step.step_id

    if ( !stepId || stepId.startsWith( 'step-' ) ) {
      // New step (temporary frontend ID) - add to step_add_list
      const newStep = transformStepForBackend( step, false ) // false = no ID needed for new steps
      updatePayload.step_add_list.push( newStep )
    } else if ( originalStepsMap.has( stepId ) ) {
      // Existing step - add to step_update_list
      const updateStep = transformStepForBackend( step, true ) // true = include ID for updates
      // Validate step ID before setting
      if ( stepId && stepId !== 'null' && stepId !== 'undefined' ) {
        // The transformStepForBackend already sets the id field, so just add to list
        updatePayload.step_update_list.push( updateStep )
      }
    }
  } )

  // Find deleted steps
  originalSteps.forEach( originalStep => {
    const stepId = originalStep.id || originalStep._id || originalStep.step_id
    if ( stepId && !currentStepsMap.has( stepId ) ) {
      // Step was deleted - validate the ID before adding
      if ( stepId && stepId !== 'null' && stepId !== 'undefined' ) {
        updatePayload.step_delete_list.push( stepId )
      }
    }
  } )

  return updatePayload
}

/**
 * Transform a single step for backend submission
 * @param {Object} step - Frontend step data
 * @param {boolean} includeId - Whether to include step ID for updates
 * @returns {Object} Backend step format
 */
export const transformStepForBackend = ( step, includeId = false ) => {
  if ( !step || typeof step !== 'object' ) {
    throw new Error( 'Invalid step data provided for transformation' )
  }

  const backendStep = {
    name : step.label || step.name || 'Untitled Step',
    description : step.description || '',
    type : 'template',
    required : Boolean( step.required ),
    remarks : step.remarks || ''
  }

  // Include ID for updates - use 'id' field for backend compatibility
  if ( includeId && ( step.step_id || step.id || step._id ) ) {
    backendStep.id = step.step_id || step.id || step._id
  }

  // Add tools if they exist (send as ID array per new API)
  if ( step.relevant_tools && Array.isArray( step.relevant_tools ) && step.relevant_tools.length > 0 ) {
    backendStep.tools = step.relevant_tools
      .map( tool => {
        if ( typeof tool === 'object' && tool.tool_id ) {
          return parseInt( tool.tool_id ) || 0
        } else if ( typeof tool === 'object' && tool.id ) {
          return parseInt( tool.id ) || 0
        } else {
          return parseInt( tool ) || 0
        }
      } )
      .filter( id => id > 0 )
  }

  // Transform step value based on frontend step type
  const stepConfig = step.config || {}
  switch ( step.type ) {
    case 'number':
      backendStep.value = {
        type : 'numeric',
        value : parseFloat( stepConfig.default_value ) || 0,
        numeric_limit_bounds : transformLimitsToBackend( stepConfig.limits ),
        require_image : Boolean( step.required_image ),
        image : []
      }
      break

    case 'checkbox':
      backendStep.value = {
        type : 'checkbox', // Backend expects 'checkbox' for checkbox steps
        value : Boolean( stepConfig.default ),
        require_image : Boolean( step.required_image ),
        image : []
      }
      break

    case 'text':
      backendStep.value = {
        type : 'text',
        value : String( stepConfig.default_value || '' ),
        require_image : Boolean( step.required_image ),
        image : []
      }
      break

    case 'inspection':
      backendStep.value = {
        type : 'inspection',
        value : stepConfig.default === 'pass',
        remarks : '',
        require_image : Boolean( step.required_image ),
        image : []
      }
      break

    case 'attachments':
      backendStep.value = {
        type : 'file',
        file : []
      }
      break

    default:
      backendStep.value = {
        type : 'checkbox', // Default to checkbox type instead of boolean
        value : false,
        require_image : Boolean( step.required_image ),
        image : []
      }
  }

  return backendStep
}
