var p={},R;function k(){if(R)return p;R=1,Object.defineProperty(p,"__esModule",{value:!0}),p.TokenData=void 0,p.parse=E,p.compile=U,p.match=M,p.pathToRegexp=C,p.stringify=O;const x="/",w=n=>n,D=/^[$_\p{ID_Start}]$/u,v=/^[$\u200c\u200d\p{ID_Continue}]$/u,m="https://git.new/pathToRegexpError",S={"{":"{","}":"}","(":"(",")":")","[":"[","]":"]","+":"+","?":"?","!":"!"};function _(n){return n.replace(/[{}()\[\]+?!:*]/g,"\\$&")}function f(n){return n.replace(/[.+*?^${}()[\]|/\\]/g,"\\$&")}function*I(n){const t=[...n];let e=0;function o(){let r="";if(D.test(t[++e]))for(r+=t[e];v.test(t[++e]);)r+=t[e];else if(t[e]==='"'){let s=e;for(;e<t.length;){if(t[++e]==='"'){e++,s=0;break}t[e]==="\\"?r+=t[++e]:r+=t[e]}if(s)throw new TypeError(`Unterminated quote at ${s}: ${m}`)}if(!r)throw new TypeError(`Missing parameter name at ${e}: ${m}`);return r}for(;e<t.length;){const r=t[e],s=S[r];if(s)yield{type:s,index:e++,value:r};else if(r==="\\")yield{type:"ESCAPED",index:e++,value:t[e++]};else if(r===":"){const u=o();yield{type:"PARAM",index:e,value:u}}else if(r==="*"){const u=o();yield{type:"WILDCARD",index:e,value:u}}else yield{type:"CHAR",index:e,value:t[e++]}}return{type:"END",index:e,value:""}}class N{constructor(t){this.tokens=t}peek(){if(!this._peek){const t=this.tokens.next();this._peek=t.value}return this._peek}tryConsume(t){const e=this.peek();if(e.type===t)return this._peek=void 0,e.value}consume(t){const e=this.tryConsume(t);if(e!==void 0)return e;const{type:o,index:r}=this.peek();throw new TypeError(`Unexpected ${o} at ${r}, expected ${t}: ${m}`)}text(){let t="",e;for(;e=this.tryConsume("CHAR")||this.tryConsume("ESCAPED");)t+=e;return t}}class g{constructor(t){this.tokens=t}}p.TokenData=g;function E(n,t={}){const{encodePath:e=w}=t,o=new N(I(n));function r(u){const i=[];for(;;){const c=o.text();c&&i.push({type:"text",value:e(c)});const a=o.tryConsume("PARAM");if(a){i.push({type:"param",name:a});continue}const h=o.tryConsume("WILDCARD");if(h){i.push({type:"wildcard",name:h});continue}if(o.tryConsume("{")){i.push({type:"group",tokens:r("}")});continue}return o.consume(u),i}}const s=r("END");return new g(s)}function U(n,t={}){const{encode:e=encodeURIComponent,delimiter:o=x}=t,r=n instanceof g?n:E(n,t),s=A(r.tokens,o,e);return function(i={}){const[c,...a]=s(i);if(a.length)throw new TypeError(`Missing parameters: ${a.join(", ")}`);return c}}function A(n,t,e){const o=n.map(r=>P(r,t,e));return r=>{const s=[""];for(const u of o){const[i,...c]=u(r);s[0]+=i,s.push(...c)}return s}}function P(n,t,e){if(n.type==="text")return()=>[n.value];if(n.type==="group"){const r=A(n.tokens,t,e);return s=>{const[u,...i]=r(s);return i.length?[""]:[u]}}const o=e||w;return n.type==="wildcard"&&e!==!1?r=>{const s=r[n.name];if(s==null)return["",n.name];if(!Array.isArray(s)||s.length===0)throw new TypeError(`Expected "${n.name}" to be a non-empty array`);return[s.map((u,i)=>{if(typeof u!="string")throw new TypeError(`Expected "${n.name}/${i}" to be a string`);return o(u)}).join(t)]}:r=>{const s=r[n.name];if(s==null)return["",n.name];if(typeof s!="string")throw new TypeError(`Expected "${n.name}" to be a string`);return[o(s)]}}function M(n,t={}){const{decode:e=decodeURIComponent,delimiter:o=x}=t,{regexp:r,keys:s}=C(n,t),u=s.map(i=>e===!1?w:i.type==="param"?e:c=>c.split(o).map(e));return function(c){const a=r.exec(c);if(!a)return!1;const h=a[0],l=Object.create(null);for(let y=1;y<a.length;y++){if(a[y]===void 0)continue;const d=s[y-1],T=u[y-1];l[d.name]=T(a[y])}return{path:h,params:l}}}function C(n,t={}){const{delimiter:e=x,end:o=!0,sensitive:r=!1,trailing:s=!0}=t,u=[],i=[],c=r?"":"i",h=(Array.isArray(n)?n:[n]).map(d=>d instanceof g?d:E(d,t));for(const{tokens:d}of h)for(const T of $(d,0,[])){const F=j(T,e,u);i.push(F)}let l=`^(?:${i.join("|")})`;return s&&(l+=`(?:${f(e)}$)?`),l+=o?"$":`(?=${f(e)}|$)`,{regexp:new RegExp(l,c),keys:u}}function*$(n,t,e){if(t===n.length)return yield e;const o=n[t];if(o.type==="group"){const r=e.slice();for(const s of $(o.tokens,0,r))yield*$(n,t+1,s)}else e.push(o);yield*$(n,t+1,e)}function j(n,t,e){let o="",r="",s=!0;for(let u=0;u<n.length;u++){const i=n[u];if(i.type==="text"){o+=f(i.value),r+=i.value,s||(s=i.value.includes(t));continue}if(i.type==="param"||i.type==="wildcard"){if(!s&&!r)throw new TypeError(`Missing text after "${i.name}": ${m}`);i.type==="param"?o+=`(${L(t,s?"":r)}+)`:o+="([\\s\\S]+)",e.push(i),r="",s=!1;continue}}return o}function L(n,t){return t.length<2?n.length<2?`[^${f(n+t)}]`:`(?:(?!${f(n)})[^${f(t)}])`:n.length<2?`(?:(?!${f(t)})[^${f(n)}])`:`(?:(?!${f(t)}|${f(n)})[\\s\\S])`}function O(n){return n.tokens.map(function t(e,o,r){if(e.type==="text")return _(e.value);if(e.type==="group")return`{${e.tokens.map(t).join("")}}`;const u=q(e.name)&&b(r[o+1])?e.name:JSON.stringify(e.name);if(e.type==="param")return`:${u}`;if(e.type==="wildcard")return`*${u}`;throw new TypeError(`Unexpected token: ${e}`)}).join("")}function q(n){const[t,...e]=n;return D.test(t)?e.every(o=>v.test(o)):!1}function b(n){return(n==null?void 0:n.type)!=="text"?!0:!v.test(n.value[0])}return p}var H=k();export{H as d};
